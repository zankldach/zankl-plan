{% extends "base.html" %}
{% block title %}Wochenplanung Zankl Dach ‚Äì KW {{ kw }} / {{ year }}{% endblock %}

{% block head %}
<style>
  .layout { display:grid; grid-template-columns: 1fr 320px; gap:12px; align-items:start; }
  header.page { display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; }

  .toolbar { display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin-bottom:8px; }
  .toolbar .group { display:flex; gap:8px; align-items:center; }
  .toolbar select, .toolbar button, .toolbar input[type="checkbox"] { padding:6px 8px; font-size:14px; }
  .toolbar .badge { display:inline-block; padding:4px 8px; background:#eef2f6; border-radius:999px; font-size:12px; color:#334155; }

  .planner{
    width:100%; border-collapse:separate; border-spacing:0; table-layout:fixed;
    background:#fff; border:1px solid #d9dee5; border-radius:8px; overflow:hidden;
    box-shadow:0 3px 12px rgba(0,0,0,0.06);
  }
  .planner thead th{
    position:sticky; top:0; z-index:3; background:#0b57d0; color:#fff; padding:8px 6px; font-weight:700;
    border-bottom:1px solid rgba(255,255,255,0.2); text-align:center;
  }
  .planner thead th:first-child,
  .planner tbody td:first-child{
    position:sticky; left:0; z-index:2; background:#f7f9fc; font-weight:600; width:180px; text-align:left;
  }
  .planner tbody td{ border-top:1px solid #eef2f6; border-right:1px solid #eef2f6; padding:0 6px; height:54px; vertical-align:middle; }
  .planner tbody tr:nth-child(even) td:first-child{ background:#f1f5fb; }
  .planner tbody tr:hover td{ background:#fbfdff; }

  .planner textarea.cell{
    width:100%; height:46px; padding:4px 6px; border:none; background:transparent;
    text-align:center; font-size:13px; outline:none; resize:vertical; line-height:1.2;
  }
  .planner textarea.cell:focus{ outline:2px solid #7db3ff; background:#fff; border-radius:6px; }

  .drag-over{ outline:2px dashed #2196f3; outline-offset:-4px; background:#eef7ff !important; }
  .paint-select{ outline:2px dashed #fb923c; outline-offset:-4px; background:#fff7ed !important; }

  /* Freitag (4-Tage-Woche) */
  td.cell-friday-locked { background:#e2e8f0 !important; }
  td.cell-friday-locked textarea.cell { color:#475569; }

  /* Sidebar */
  .side { background:#fff; border:1px solid #d9dee5; border-radius:8px; box-shadow:0 3px 12px rgba(0,0,0,0.06); }
  .side header { background:#0b57d0; color:#fff; padding:8px 12px; font-weight:700; border-bottom:1px solid rgba(255,255,255,0.2); position:sticky; top:0; z-index:2; }
  .side .list { max-height:70vh; overflow-y:auto; padding:8px 12px; }
  .side .row { display:flex; align-items:center; gap:8px; margin-bottom:8px; position:relative; }
  .side .row .drag-handle { cursor:grab; user-select:none; }
  .side .row input.job {
    flex:1; padding:6px 8px; border:1px solid #d9dee5; border-radius:6px;
    opacity:1 !important; visibility:visible !important; pointer-events:auto !important;
    color:#111 !important; background:#fff !important;
  }

  /* Autocomplete */
  #titleSuggest{
    position: fixed;
    z-index: 9999;
    display: none;
    min-width: 260px;
    max-width: 420px;
    max-height: 220px;
    overflow: auto;
    background: #fff;
    border: 1px solid #d9dee5;
    border-radius: 10px;
    box-shadow: 0 10px 30px rgba(0,0,0,.12);
    padding: 6px;
  }
  #titleSuggest .item{
    padding: 8px 10px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 13px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  #titleSuggest .item:hover{ background:#f8fafc; }
  #titleSuggest .item.active{ background:#eef7ff; outline: 1px solid #7db3ff; }
</style>
{% endblock %}

{% block content %}
<header class="page">
  <strong style="font-size:18px;">Zankl Dach ‚Äì Wochenplanung</strong>
</header>

<div class="toolbar">
  <div class="group">
    <button id="prevWeekBtn" title="Vorige Woche">‚Üê</button>
    <label for="kwSelect">KW:</label>
    <select id="kwSelect"></select>
    <label for="yearSelect">Jahr:</label>
    <select id="yearSelect"></select>
    <button id="nextWeekBtn" title="N√§chste Woche">‚Üí</button>
    <span class="badge">KW {{ kw }} / {{ year }}</span>
  </div>
  <div class="group">
    <label for="fourDayChk">4-Tage-Woche:</label>
    <input type="checkbox" id="fourDayChk" {% if four_day_week %}checked{% endif %} />
  </div>
</div>

<div class="layout">
  <!-- LINKS: beide Wochen untereinander -->
  <div>
    <!-- Aktuelle Woche -->
    <div class="plan-wrap">
      <div class="week-grid" data-week-grid data-year="{{ year }}" data-kw="{{ kw }}" data-standort="{{ standort }}">
        <table class="planner" id="weekTable">
          <thead>
            <tr>
              <th>Mitarbeiter / Tag</th>
              {% for day in days %}
                <th>{{ day.label }}<br><small>{{ day.date }}</small></th>
              {% endfor %}
            </tr>
          </thead>
          <tbody>
            {% for row in grid %}
              {% set r = loop.index0 %}
              <tr>
                <td>
                  {% if employees and employees|length > r and employees[r] %}
                    {{ employees[r].name }}
                  {% else %}Unbenannt{% endif %}
                </td>
                {% for cell in row %}
                  {% set d = loop.index0 %}
                  <td data-row="{{ r }}" data-day="{{ d }}" class="{% if four_day_week and d == 4 %}cell-friday-locked{% endif %}">
                    <textarea class="cell" draggable="true" data-row="{{ r }}" data-day="{{ d }}" rows="2">{{ cell.text if cell and cell.text is defined else '' }}</textarea>
                  </td>
                {% endfor %}
              </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
    </div>

    <hr style="margin:16px 0; border:none; border-top:1px solid rgba(0,0,0,0.15);">

    <div style="display:flex; justify-content:space-between; align-items:center; margin:6px 0 10px;">
      <div style="font-weight:700;">
        N√§chste Woche: KW {{ next_kw }} / {{ next_year }}
      </div>
      <div style="opacity:.75; font-size:12px;">
        Ziehen = verschieben ¬∑ STRG/CMD+Ziehen = kopieren
      </div>
    </div>

    <!-- N√§chste Woche -->
    <div class="plan-wrap">
      <div class="week-grid" data-week-grid data-year="{{ next_year }}" data-kw="{{ next_kw }}" data-standort="{{ standort }}">
        <table class="planner" id="weekTableNext">
          <thead>
            <tr>
              <th>Mitarbeiter / Tag</th>
              {% for day in next_days %}
                <th>{{ day.label }}<br><small>{{ day.date }}</small></th>
              {% endfor %}
            </tr>
          </thead>
          <tbody>
            {% for row in next_grid %}
              {% set r = loop.index0 %}
              <tr>
                <td>
                  {% if employees and employees|length > r and employees[r] %}
                    {{ employees[r].name }}
                  {% else %}Unbenannt{% endif %}
                </td>
                {% for cell in row %}
                  {% set d = loop.index0 %}
                  <td data-row="{{ r }}" data-day="{{ d }}" class="{% if next_four_day_week and d == 4 %}cell-friday-locked{% endif %}">
                    <textarea class="cell" draggable="true" data-row="{{ r }}" data-day="{{ d }}" rows="2">{{ cell.text if cell and cell.text is defined else '' }}</textarea>
                  </td>
                {% endfor %}
              </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- RECHTS: Kleinbaustellen -->
  <div>
    <div class="side">
      <header>Kleinbaustellen</header>
      <div class="list" id="kleinList">
        {% set list = small_jobs or [] %}
        {% for item in list %}
          {% set txt = (item if item is string else (item.text if item.text is defined else '')) %}
          <div class="row">
            <span class="drag-handle" title="Ziehen in Wochenzelle" draggable="true">‚ãÆ‚ãÆ</span>
            <input type="text" class="job" data-row="{{ loop.index0 }}" value="{{ txt }}" placeholder="">
          </div>
        {% endfor %}
        {% if (not list) or (list|length==0) %}
          <div class="row">
            <span class="drag-handle" title="Ziehen in Wochenzelle" draggable="true">‚ãÆ‚ãÆ</span>
            <input type="text" class="job" data-row="0" value="" placeholder="">
          </div>
        {% endif %}
      </div>
    </div>
  </div>
</div>

<div id="titleSuggest"></div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', () => {
  try {
    const KW = parseInt('{{ kw }}', 10);
    const YEAR = parseInt('{{ year }}', 10);
    const CURLOC = "{{ (standort|string) }}";
    const MAX_WEEKS = 53;

    const kwSel = document.getElementById('kwSelect');
    const yearSel = document.getElementById('yearSelect');
    const fourChk = document.getElementById('fourDayChk');

    // DnD Status
    let DND_COPY = false;
    let DND_FROM = null; // 'grid' | 'klein' | null

    /* =======================
       KW/Jahr f√ºllen + Navigation
       ======================= */
    (function initSelectors(){
      if (kwSel && kwSel.options.length === 0) {
        for (let w=1; w<=MAX_WEEKS; w++){
          const opt = document.createElement('option');
          opt.value = w; opt.textContent = w;
          if (w === KW) opt.selected = true;
          kwSel.appendChild(opt);
        }
      }
      if (yearSel && yearSel.options.length === 0) {
        [YEAR-1, YEAR, YEAR+1].forEach(y=>{
          const opt = document.createElement('option');
          opt.value = y; opt.textContent = y;
          if (y === YEAR) opt.selected = true;
          yearSel.appendChild(opt);
        });
      }
    })();

    function navigate(kw, year){
      window.location.href = `/week?standort=${encodeURIComponent(CURLOC)}&kw=${kw}&year=${year}`;
    }

    kwSel?.addEventListener('change', ()=> navigate(parseInt(kwSel.value,10), parseInt(yearSel.value,10)));
    yearSel?.addEventListener('change', ()=> navigate(parseInt(kwSel.value,10), parseInt(yearSel.value,10)));

    document.getElementById('prevWeekBtn').onclick = ()=>{
      const kw = parseInt(kwSel?.value ?? KW,10);
      const yr = parseInt(yearSel?.value ?? YEAR,10);
      const p = (kw>1) ? {kw: kw-1, year: yr} : {kw: MAX_WEEKS, year: yr-1};
      navigate(p.kw, p.year);
    };
    document.getElementById('nextWeekBtn').onclick = ()=>{
      const kw = parseInt(kwSel?.value ?? KW,10);
      const yr = parseInt(yearSel?.value ?? YEAR,10);
      const n = (kw<MAX_WEEKS) ? {kw: kw+1, year: yr} : {kw: 1, year: yr+1};
      navigate(n.kw, n.year);
    };

    /* =======================
       Meta pro Grid (wichtig f√ºr 2 Tabellen)
       ======================= */
    function metaFromEl(el){
      const grid = el.closest('[data-week-grid]');
      if (!grid) return { year: YEAR, kw: KW, standort: CURLOC };
      return {
        year: parseInt(grid.dataset.year || YEAR, 10),
        kw: parseInt(grid.dataset.kw || KW, 10),
        standort: grid.dataset.standort || CURLOC
      };
    }

    function isLockedCell(el){
      const td = el.closest('td');
      return !!(td && td.classList.contains('cell-friday-locked'));
    }

    /* =======================
       4-Tage-Woche (Checkbox wirkt nur auf AKTUELLE Woche)
       ======================= */
    function applyFourDayWeekUI(flag){
      document.querySelectorAll('#weekTable td[data-day="4"]').forEach(td=>{
        const ta = td.querySelector('textarea.cell');
        if (flag) {
          td.classList.add('cell-friday-locked');
          if (ta) ta.readOnly = true;
        } else {
          td.classList.remove('cell-friday-locked');
          if (ta) ta.readOnly = false;
        }
      });
    }

    function applyReadOnlyByDomLocks(){
      document.querySelectorAll('.planner td.cell-friday-locked textarea.cell').forEach(ta => {
        ta.readOnly = true;
      });
    }

    async function setFourDayWeek(flag){
      const payload = {
        year: parseInt(yearSel?.value ?? YEAR, 10),
        kw: parseInt(kwSel?.value ?? KW, 10),
        standort: CURLOC,
        four_day_week: !!flag
      };
      try{
        const res = await fetch('/api/week/options', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify(payload)
        });
        if (!res.ok) console.warn('4-Tage-Woche speichern fehlgeschlagen', await res.text());
      }catch(e){ console.warn('Netz-/Serverfehler bei 4-Tage-Woche:', e); }
    }

    applyReadOnlyByDomLocks(); // setzt readOnly f√ºr beide Tabellen anhand der Klassen
    applyFourDayWeekUI(!!({{ 1 if four_day_week else 0 }})); // stellt AKTUELLE Woche sicher konsistent
    fourChk?.addEventListener('change', async ()=>{
      applyFourDayWeekUI(fourChk.checked);
      applyColors();
      await setFourDayWeek(fourChk.checked);
    });

    /* =======================
       Farben (Baustellen-Farbgebung)
       ======================= */
    const RESERVED_RED = new Set(["urlaub","krank","arzt","za","xxx","x","xx"]);
    const norm = s => (s||"").trim().toLowerCase().replace(/\s+/g, " ");
    function hashCode(str){ let h=0; for(let i=0;i<str.length;i++){ h=((h<<5)-h)+str.charCodeAt(i); h|=0; } return Math.abs(h); }
    function colorFor(text){
      const n = norm(text);
      if (!n) return null;
      if (RESERVED_RED.has(n)) return { bg:"hsla(0, 85%, 67%, 0.70)", border:"hsl(0, 82%, 42%)" };
      let h = hashCode(n) % 360;
      if (h <= 20 || h >= 340) h = (h + 40) % 360;
      const s=70, l=80;
      return { bg:`hsla(${h}, ${s}%, ${l}%, 0.65)`, border:`hsl(${h}, ${s}%, ${Math.max(40, l-25)}%)` };
    }
    function applyColors(){
      document.querySelectorAll('.planner textarea.cell').forEach(inp=>{
        const c = colorFor(inp.value);
        if (c){
          inp.style.background = c.bg;
          inp.style.border = `1px solid ${c.border}`;
          inp.style.borderRadius = '6px';
        } else {
          inp.style.background = 'transparent';
          inp.style.border = 'none';
        }
      });
    }

    /* =======================
       Autocomplete: "Name, Ort" aus Jahresplanung (nur aus dem Jahr des aktiven Grids)
       ======================= */
    const SUG = document.getElementById('titleSuggest');
    const TITLES_CACHE = new Map(); // year -> array
    let sugOpenFor = null;
    let sugItems = [];
    let sugIndex = -1;
    let blurTimer = null;

    async function ensureYearTitles(year){
      if (TITLES_CACHE.has(year)) return TITLES_CACHE.get(year);
      try{
        const res = await fetch(`/api/year/titles?year=${encodeURIComponent(year)}`);
        const js = await res.json().catch(()=>({}));
        if (!res.ok || !js.ok) { TITLES_CACHE.set(year, []); return []; }
        const arr = (js.titles || []).filter(Boolean);
        TITLES_CACHE.set(year, arr);
        return arr;
      }catch(e){
        console.warn('ensureYearTitles failed', e);
        TITLES_CACHE.set(year, []);
        return [];
      }
    }

    function hideSuggest(){
      if (!SUG) return;
      SUG.style.display = 'none';
      SUG.innerHTML = '';
      sugOpenFor = null;
      sugItems = [];
      sugIndex = -1;
    }

    function positionSuggest(ta){
      if (!SUG || !ta) return;
      const r = ta.getBoundingClientRect();
      const margin = 6;
      let left = r.left;
      let top  = r.bottom + margin;

      const wantH = 240;
      if (top + wantH > window.innerHeight) {
        top = r.top - margin;
        SUG.style.transform = 'translateY(-100%)';
      } else {
        SUG.style.transform = 'none';
      }

      left = Math.max(6, Math.min(left, window.innerWidth - 440));
      SUG.style.left = `${left}px`;
      SUG.style.top  = `${top}px`;
    }

    function renderSuggest(list, activeIdx){
      if (!SUG) return;
      SUG.innerHTML = '';
      list.forEach((t, i) => {
        const div = document.createElement('div');
        div.className = 'item' + (i === activeIdx ? ' active' : '');
        div.textContent = t;
        div.addEventListener('mousedown', (e)=>{
          e.preventDefault();
          applySuggestion(t);
        });
        SUG.appendChild(div);
      });
      SUG.style.display = list.length ? 'block' : 'none';
    }

    function getQueryFromTextarea(ta){
      const v = ta.value || '';
      const pos = ta.selectionStart ?? v.length;
      const upTo = v.slice(0, pos);
      const lastNl = upTo.lastIndexOf('\n');
      return upTo.slice(lastNl + 1).trim();
    }

    function buildMatches(titles, q){
      const qq = (q || '').trim().toLowerCase();
      if (qq.length < 2) return [];
      const starts = [];
      const contains = [];
      for (const t of titles){
        const tl = String(t).toLowerCase();
        if (tl.startsWith(qq)) starts.push(t);
        else if (tl.includes(qq)) contains.push(t);
        if (starts.length >= 10) break;
      }
      for (const t of contains){
        if (starts.length >= 10) break;
        starts.push(t);
      }
      return starts.slice(0, 10);
    }

    async function showSuggestFor(ta){
      if (!SUG || !ta) return;
      const m = metaFromEl(ta);
      const titles = await ensureYearTitles(m.year);

      const q = getQueryFromTextarea(ta);
      const matches = buildMatches(titles, q);

      sugOpenFor = ta;
      sugItems = matches;
      sugIndex = matches.length ? 0 : -1;

      positionSuggest(ta);
      renderSuggest(matches, sugIndex);
    }

    function applySuggestion(text){
      const ta = sugOpenFor;
      if (!ta) return;

      const v = ta.value || '';
      const pos = ta.selectionStart ?? v.length;

      const upTo = v.slice(0, pos);
      const after = v.slice(pos);
      const lastNl = upTo.lastIndexOf('\n');
      const lineStart = lastNl + 1;

      const beforeLine = v.slice(0, lineStart);
      const newVal = beforeLine + text + after;
      ta.value = newVal;

      const newPos = (beforeLine + text).length;
      ta.focus();
      ta.setSelectionRange(newPos, newPos);

      hideSuggest();

      saveCellForEl(ta, ta.dataset.row, ta.dataset.day, ta.value).then(applyColors);
    }

    window.addEventListener('scroll', ()=>{ if (sugOpenFor) positionSuggest(sugOpenFor); }, true);
    window.addEventListener('resize', ()=>{ if (sugOpenFor) positionSuggest(sugOpenFor); });

    document.addEventListener('mousedown', (e)=>{
      if (!SUG || SUG.style.display !== 'block') return;
      if (SUG.contains(e.target)) return;
      if (sugOpenFor && sugOpenFor.contains(e.target)) return;
      hideSuggest();
    });

    /* =======================
       Speichern
       ======================= */
    async function saveCellForEl(el, row, day, value){
      const m = metaFromEl(el);

      // gesperrt? (egal ob current oder next)
      if (isLockedCell(el)) return true;

      try{
        const res = await fetch('/api/week/set-cell', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({
            row:Number(row),
            day:Number(day),
            value: value ?? "",
            kw: m.kw,
            year: m.year,
            standort: m.standort
          })
        });
        if (!res.ok){ console.warn('Save HTTP-Fehler:', res.status); return false; }
        const r = await res.json().catch(()=>({ok:true}));
        if(!r.ok){ console.warn('Save-Fehler:', r.error); return false; }
        return true;
      }catch(e){ console.warn('Netz-/Serverfehler:', e); return false; }
    }

    async function saveBatchForEl(el, updates){
      const m = metaFromEl(el);

      // gesperrte Freitage ausfiltern (pro Ziel-Grid anhand DOM)
      updates = updates.filter(u => {
        const ta = el.closest('table')?.querySelector(`textarea.cell[data-row="${u.row}"][data-day="${u.day}"]`);
        if (!ta) return true;
        return !isLockedCell(ta);
      });

      try{
        const res = await fetch('/api/week/batch', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ year: m.year, kw: m.kw, standort: m.standort, updates })
        });
        if (!res.ok){ console.warn('Batch HTTP-Fehler:', res.status); return false; }
        const r = await res.json().catch(()=>({ok:true}));
        if(!r.ok){ console.warn('Batch-Fehler:', r.error); return false; }
        return true;
      }catch(e){ console.warn('Netz-/Serverfehler:', e); return false; }
    }

    /* =======================
       Shift-F√ºllen (pro Tabelle)
       ======================= */
    const fillState = { active:false, row:null, startDay:null, lastDay:null, value:"", grid:null };

    function getTd(grid, row, day){ return grid.querySelector(`td[data-row="${row}"][data-day="${day}"]`); }
    function getTa(grid, row, day){ return grid.querySelector(`textarea.cell[data-row="${row}"][data-day="${day}"]`); }

    function paintRange(grid, row, d1, d2, on=true){
      const [from,to] = d1<=d2 ? [d1,d2] : [d2,d1];
      for (let d=from; d<=to; d++){
        const td = getTd(grid, row, d); if (!td) continue;
        const ta = td.querySelector('textarea.cell');
        if (ta && isLockedCell(ta)) continue;
        td.classList.toggle('paint-select', on);
      }
    }

    function startFill(grid, row, day, value){
      fillState.active=true; fillState.grid=grid;
      fillState.row=row; fillState.startDay=day; fillState.lastDay=day; fillState.value=value||"";
      paintRange(grid, row, day, day, true);
    }
    function updateFill(day){
      if (!fillState.active) return;
      paintRange(fillState.grid, fillState.row, fillState.startDay, fillState.lastDay, false);
      fillState.lastDay=day;
      paintRange(fillState.grid, fillState.row, fillState.startDay, fillState.lastDay, true);
    }
    async function endFill(){
      if (!fillState.active) return;
      const grid = fillState.grid;
      const row = fillState.row;
      const d1 = Math.min(fillState.startDay, fillState.lastDay);
      const d2 = Math.max(fillState.startDay, fillState.lastDay);

      const updates = [];
      for (let d=d1; d<=d2; d++){
        const ta = getTa(grid, row, d); if (!ta) continue;
        if (isLockedCell(ta)) continue;
        ta.value = fillState.value;
        updates.push({ row, day:d, value: fillState.value });
      }
      const anyTa = getTa(grid, row, d1) || grid;
      await saveBatchForEl(anyTa, updates);
      applyColors();
      paintRange(grid, row, d1, d2, false);

      fillState.active=false; fillState.row=null; fillState.startDay=null; fillState.lastDay=null; fillState.value=""; fillState.grid=null;
    }

    document.addEventListener('mouseup', endFill);
    document.addEventListener('mouseleave', endFill);

    /* =======================
       Grid: Inputs + Autocomplete + DragStart/Drop
       ======================= */
    document.querySelectorAll('.planner textarea.cell').forEach(inp=>{
      // initial readOnly, wenn gesperrt
      if (isLockedCell(inp)) inp.readOnly = true;

      // live Farben
      inp.addEventListener('input', ()=> applyColors());

      // Autocomplete bei Fokus / Eingabe (nur wenn nicht gesperrt)
      inp.addEventListener('focus', ()=>{
        clearTimeout(blurTimer);
        if (!isLockedCell(inp)) showSuggestFor(inp);
      });
      inp.addEventListener('input', ()=>{
        if (isLockedCell(inp)) return;
        showSuggestFor(inp);
      });
      inp.addEventListener('blur', ()=>{
        clearTimeout(blurTimer);
        blurTimer = setTimeout(hideSuggest, 140);
      });

      // Speichern bei Blur (wenn nicht gesperrt)
      inp.addEventListener('blur', async ()=>{
        if (isLockedCell(inp)) return;
        await saveCellForEl(inp, inp.dataset.row, inp.dataset.day, inp.value);
        applyColors();
      });

      // Keydown: Autocomplete steuern / Enter speichern
      inp.addEventListener('keydown', async (ev)=>{
        if (SUG && SUG.style.display === 'block' && sugOpenFor === inp && sugItems && sugItems.length){
          if (ev.key === 'ArrowDown'){
            ev.preventDefault();
            sugIndex = Math.min(sugItems.length-1, sugIndex+1);
            renderSuggest(sugItems, sugIndex);
            return;
          }
          if (ev.key === 'ArrowUp'){
            ev.preventDefault();
            sugIndex = Math.max(0, sugIndex-1);
            renderSuggest(sugItems, sugIndex);
            return;
          }
          if (ev.key === 'Enter' && !ev.shiftKey){
            ev.preventDefault();
            if (sugIndex >= 0 && sugItems[sugIndex]) applySuggestion(sugItems[sugIndex]);
            return;
          }
          if (ev.key === 'Escape'){
            ev.preventDefault();
            hideSuggest();
            return;
          }
        }

        if (ev.key === 'Enter' && !ev.shiftKey){
          ev.preventDefault();
          if (isLockedCell(inp)) return;
          await saveCellForEl(inp, inp.dataset.row, inp.dataset.day, inp.value);
          applyColors();
        }
      });

      // DragStart (Grid -> Grid)
     inp.addEventListener('dragstart', (e)=>{
  if (isLockedCell(inp)) { e.preventDefault(); return; }

  const m = metaFromEl(inp);

  // üëá WICHTIG: Copy-Status hier merken
  DND_COPY = !!(e.ctrlKey || e.metaKey);
  DND_FROM = 'grid';

  const payload = {
    source: 'grid',
    row: Number(inp.dataset.row),
    day: Number(inp.dataset.day),
    value: inp.value || '',
    year: m.year,
    kw: m.kw
  };

  const s = JSON.stringify(payload);
  try{ e.dataTransfer.setData('application/json', s); }catch(_){}
  try{ e.dataTransfer.setData('text/plain', s); }catch(_){}

  e.dataTransfer.effectAllowed = DND_COPY ? 'copy' : 'move';
});


      inp.addEventListener('dragend', ()=>{
        DND_FROM = null;
        DND_COPY = false;
        document.querySelectorAll('.drag-over').forEach(el=>el.classList.remove('drag-over'));
      });
    });

    // TD Events f√ºr beide Tabellen (Shift-Fill + Drop Targets)
    document.querySelectorAll('.planner td[data-row][data-day]').forEach(td=>{
      const grid = td.closest('table.planner');

      td.addEventListener('mousedown', (e)=>{
        if (e.button !== 0) return;
        if (!e.shiftKey) return;

        const ta = td.querySelector('textarea.cell');
        if (!ta || isLockedCell(ta)) return;

        e.preventDefault();
        startFill(grid, Number(td.dataset.row), Number(td.dataset.day), ta.value ?? "");
      });

      td.addEventListener('mouseenter', ()=>{
        if (!fillState.active) return;
        if (fillState.grid !== grid) return;
        updateFill(Number(td.dataset.day));
      });

      td.addEventListener('dragover', (e)=>{
        if (fillState.active) return;

        const ta = td.querySelector('textarea.cell');
        if (ta && isLockedCell(ta)) return;

        if (DND_FROM === 'klein'){
          e.dataTransfer.dropEffect = 'copy';
        } else {
          DND_COPY = !!(e.ctrlKey || e.metaKey);
          e.dataTransfer.dropEffect = DND_COPY ? 'copy' : 'move';
        }
        e.preventDefault();
        td.classList.add('drag-over');
      });

      td.addEventListener('dragleave', ()=> td.classList.remove('drag-over'));

      td.addEventListener('drop', async (e)=>{
        td.classList.remove('drag-over');
        if (fillState.active) return;

        const tgt = td.querySelector('textarea.cell');
        if (!tgt || isLockedCell(tgt)) return;

        e.preventDefault();

        let dataStr =
          e.dataTransfer.getData('application/json') ||
          e.dataTransfer.getData('text/plain') || '';
        let payload = {};
        try { payload = JSON.parse(dataStr || '{}'); } catch(_) { payload = {}; }

        const targetRow = Number(td.dataset.row);
        const targetDay = Number(td.dataset.day);

        // Grid -> Grid
        if (payload && payload.source === 'grid'){
          const text = (payload.value || '');
          const srcR = Number(payload.row);
          const srcD = Number(payload.day);
          const srcYear = Number(payload.year);
          const srcKw = Number(payload.kw);

          tgt.value = text;
          await saveCellForEl(tgt, targetRow, targetDay, text);
          applyColors();

          // MOVE: Quelle leeren (auch wenn andere Woche) ‚Äì au√üer Copy gedr√ºckt
          if (!DND_COPY && !(srcYear === metaFromEl(tgt).year && srcKw === metaFromEl(tgt).kw && srcR === targetRow && srcD === targetDay)){
            try{
              // Quelle finden (passende Tabelle anhand year/kw)
              const srcGrid = Array.from(document.querySelectorAll('[data-week-grid]'))
                .find(g => Number(g.dataset.year) === srcYear && Number(g.dataset.kw) === srcKw);

              const srcTa = srcGrid
                ? srcGrid.querySelector(`textarea.cell[data-row="${srcR}"][data-day="${srcD}"]`)
                : null;

              if (srcTa && !isLockedCell(srcTa)){
                srcTa.value = '';
                await saveCellForEl(srcTa, srcR, srcD, '');
                applyColors();
              }
            }catch(_){}
          }
          return;
        }

        // Klein -> Grid
        if (payload && payload.source === 'klein'){
          const text = (payload.value || '').trim();
          tgt.value = text;
          await saveCellForEl(tgt, targetRow, targetDay, text);
          applyColors();
          return;
        }
      });
    });

    /* =======================
       Kleinbaustellen (DnD + Save + immer leere Endzeile)
       ======================= */
    (function () {
      const LIST = document.getElementById('kleinList');
      if (!LIST) return;

      function debounce(fn, wait) { let t=null; return function(...a){ clearTimeout(t); t=setTimeout(()=>fn.apply(this,a), wait);} }

      async function saveKlein(rowIndex, text) {
        try {
          const payload = { standort: CURLOC, row_index: Number(rowIndex||0), text: (text||'').trim() };
          await fetch('/api/klein/set', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        } catch (e) { console.warn('Netz-/Serverfehler Kleinbaustellen:', e); }
      }

      function makeRow(idx, value="") {
        const row = document.createElement('div');
        row.className = 'row';
        row.innerHTML = `
          <span class="drag-handle" title="Ziehen in Wochenzelle" draggable="true">‚ãÆ‚ãÆ</span>
          <input type="text" class="job" data-row="${idx}" value="${(value||'').replace(/"/g,'&quot;')}" placeholder="">
        `;
        LIST.appendChild(row);
        wireRow(row);
        return row;
      }

      function ensureTrailingEmpty() {
        const inputs = Array.from(LIST.querySelectorAll('input.job'));
        const last = inputs[inputs.length - 1];
        if (!last) { makeRow(0, ""); return; }
        if ((last.value || '').trim() !== '') {
          const nextIdx = Math.max(...inputs.map(i => Number(i.dataset.row)||0), -1) + 1;
          makeRow(nextIdx, "");
        }
      }

      function wireRow(rowEl) {
        const handle = rowEl.querySelector('.drag-handle');
        const inp    = rowEl.querySelector('input.job');
        const debouncedSave = debounce(() => { saveKlein(inp.dataset.row, inp.value); }, 400);

        inp.addEventListener('blur',     () => saveKlein(inp.dataset.row, inp.value));
        inp.addEventListener('keydown',  (ev)=>{ if (ev.key==='Enter'){ ev.preventDefault(); saveKlein(inp.dataset.row, inp.value);} });
        inp.addEventListener('input',    ()=>{ debouncedSave(); ensureTrailingEmpty(); });

        function setDragPayload(dt, obj){
          const s = JSON.stringify(obj || {});
          try{ dt.setData('application/json', s); }catch(_){}
          try{ dt.setData('text/plain', s); }catch(_){}
        }

        [handle, inp].forEach(draggable=>{
          draggable.setAttribute('draggable','true');
          draggable.addEventListener('dragstart', (e)=>{
            const value = (inp.value || '').trim();
            setDragPayload(e.dataTransfer, { source:'klein', value });
            e.dataTransfer.effectAllowed = 'copy';
            DND_FROM = 'klein';
          });
          draggable.addEventListener('dragend', ()=>{ DND_FROM = null; });
        });
      }

      LIST.querySelectorAll('.row').forEach(wireRow);
      ensureTrailingEmpty();
    })();

    // Initial
    applyColors();
  } catch (err) {
    console.error('Init-Fehler in week.html:', err);
    alert('Fehler beim Laden der Wochenansicht. Bitte Strg+F5.');
  }
});
</script>
{% endblock %}
